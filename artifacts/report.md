# Python FastAPI

## Summary

Research Summary for "Python FastAPI" (comprehensive strategy):

Found 3 relevant findings.

Key findings:
- Finding from FastAPI: FastAPI Skip to content Follow @fastapi on X (Twitter) to stay updated Follow FastAPI on LinkedIn to stay updated Subscribe to the FastAPI and friends newsletter 🎉 sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor FastAPI FastAPI en - English de - Deutsch es - español fa - فارسی fr - français ja - 日本語 ko - 한국어 pt - português ru - русский язык tr - Türkçe uk - українська мова vi - Tiếng Việt zh - 简体中文 zh-hant - 繁體中文 😉 Initializing search fastapi/fastapi FastAPI Features Learn Reference FastAPI People Resources About Release Notes FastAPI fastapi/fastapi FastAPI FastAPI Table of contents Sponsors Opinions Typer , the FastAPI of CLIs Requirements Installation Example Create it Run it Check it Interactive API docs Alternative API docs Example upgrade Interactive API docs upgrade Alternative API docs upgrade Recap Performance Dependencies standard Dependencies Without standard Dependencies Without fastapi-cloud-cli Additional Optional Dependencies License Features Learn Learn Python Types Intro Concurrency and async / await Environment Variables Virtual Environments Tutorial - User Guide Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Query Parameter Models Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Cookie Parameter Models Header Parameter Models Response Model - Return Type Extra Models Response Status Code Form Data Form Models Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: lifespan and startup - shutdown Testing Dependencies with Overrides Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generating SDKs FastAPI CLI Deployment Deployment About FastAPI versions About HTTPS Run a Server Manually Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Uvicorn with Workers FastAPI in Containers - Docker How To - Recipes How To - Recipes General - How To - Recipes GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Testing a Database Reference Reference FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient FastAPI People Resources Resources Help FastAPI - Get Help Development - Contributing Full Stack FastAPI Template External Links and Articles FastAPI and friends newsletter Repository Management Tasks About About Alternatives, Inspiration and Comparisons History, Design and Future Benchmarks Repository Management Release Notes Table of contents Sponsors Opinions Typer , the FastAPI of CLIs Requirements Installation Example Create it Run it Check it Interactive API docs Alternative API docs Example upgrade Interactive API docs upgrade Alternative API docs upgrade Recap Performance Dependencies standard Dependencies Without standard Dependencies Without fastapi-cloud-cli Additional Optional Dependencies License FastAPI &para; FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation : https://fastapi.tiangolo.com Source Code : https://github.com/fastapi/fastapi FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. The key features are: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%. * Fewer bugs : Reduce about 40% of human (developer) induced errors. * Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . * estimation based on tests on an internal development team, building production applications. Sponsors &para; Other sponsors Opinions &para; " [...] I'm using FastAPI a ton these days. [...] I'm actually planning to use it for all of my team's ML services at Microsoft . Some of them are getting integrated into the core Windows product and some Office products. " Kabir Khan - Microsoft (ref) " We adopted the FastAPI library to spawn a REST server that can be queried to obtain predictions . [for Ludwig] " Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - Uber (ref) " Netflix is pleased to announce the open-source release of our crisis management orchestration framework: Dispatch ! [built with FastAPI ] " Kevin Glisson, Marc Vilanova, Forest Monsen - Netflix (ref) " I’m over the moon excited about FastAPI . It’s so fun! " Brian Okken - Python Bytes podcast host (ref) " Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted Hug to be - it's really inspiring to see someone build that. " Timothy Crosley - Hug creator (ref) " If you're looking to learn one modern framework for building REST APIs, check out FastAPI [...] It's fast, easy to use and easy to learn [...] " " We've switched over to FastAPI for our APIs [...] I think you'll like it [...] " Ines Montani - Matthew Honnibal - Explosion AI founders - spaCy creators (ref) - (ref) " If anyone is looking to build a production Python API, I would highly recommend FastAPI . It is beautifully designed , simple to use and highly scalable , it has become a key component in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer. " Deon Pillsbury - Cisco (ref) Typer , the FastAPI of CLIs &para; If you are building a CLI app to be used in the terminal instead of a web API, check out Typer . Typer is FastAPI's little sibling. And it's intended to be the FastAPI of CLIs . ⌨️ 🚀 Requirements &para; FastAPI stands on the shoulders of giants: Starlette for the web parts. Pydantic for the data parts. Installation &para; Create and activate a virtual environment and then install FastAPI: $ pip install &quot;fastapi[standard]&quot; ---&gt; 100% Note : Make sure you put "fastapi[standard]" in quotes to ensure it works in all terminals. Example &para; Create it &para; Create a file main.py with: from typing import Union from fastapi import FastAPI app = FastAPI () @app . get ( &quot;/&quot; ) def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } Or use async def ... If your code uses async / await , use async def : from typing import Union from fastapi import FastAPI app = FastAPI () @app . get ( &quot;/&quot; ) async def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) async def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } Note : If you don't know, check the "In a hurry?" section about async and await in the docs . Run it &para; Run the server with: $ fastapi dev main.py ╭────────── FastAPI CLI - Development mode ───────────╮ │ │ │ Serving at: http://127.0.0.1:8000 │ │ │ │ API docs: http://127.0.0.1:8000/docs │ │ │ │ Running in development mode, for production use: │ │ │ │ fastapi run │ │ │ ╰─────────────────────────────────────────────────────╯ INFO: Will watch for changes in these directories: [&#39;/home/user/code/awesomeapp&#39;] INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [2248755] using WatchFiles INFO: Started server process [2248757] INFO: Waiting for application startup. INFO: Application startup complete. About the command fastapi dev main.py ... The command fastapi dev reads your main.py file, detects the FastAPI app in it, and starts a server using Uvicorn . By default, fastapi dev will start with auto-reload enabled for local development. You can read more about it in the FastAPI CLI docs . Check it &para; Open your browser at http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { &quot;item_id&quot; : 5 , &quot;q&quot; : &quot;somequery&quot; } You already created an API that: Receives HTTP requests in the paths / and /items/{item_id} . Both paths take GET operations (also known as HTTP methods ). The path /items/{item_id} has a path parameter item_id that should be an int . The path /items/{item_id} has an optional str query parameter q . Interactive API docs &para; Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ): Alternative API docs &para; And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ): Example upgrade &para; Now modify the file main.py to receive a body from a PUT request. Declare the body using standard Python types, thanks to Pydantic. from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str price : float is_offer : Union [ bool , None ] = None @app . get ( &quot;/&quot; ) def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } @app . put ( &quot;/items/ {item_id} &quot; ) def update_item ( item_id : int , item : Item ): return { &quot;item_name&quot; : item . name , &quot;item_id&quot; : item_id } The fastapi dev server should reload automatically. Interactive API docs upgrade &para; Now go to http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API: Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade &para; And now, go to http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body: Recap &para; In summary, you declare once the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python . For example, for an int : item_id : int or for a more complex Item model: item : Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str , int , float , bool , list , etc). datetime objects. UUID objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example, FastAPI will: Validate that there is an item_id in the path for GET and PUT requests. Validate that the item_id is of type int for GET and PUT requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery ) for GET requests. As the q parameter is declared with = None , it is optional. Without the None it would be required (as is the body in the case with PUT ). For PUT requests to /items/{item_id} , read the body as JSON: Check that it has a required attribute name that should be a str . Check that it has a required attribute price that has to be a float . Check that it has an optional attribute is_offer , that should be a bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return { &quot;item_name&quot; : item . name , &quot;item_id&quot; : item_id } ...from: ... &quot;item_name&quot; : item . name ... ...to: ... &quot;item_price&quot; : item . price ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of parameters from other different places as: headers , cookies , form fields and files . How to set validation constraints as maximum_length or regex . A very powerful and easy to use Dependency Injection system. Security and authentication, including support for OAuth2 with JWT tokens and HTTP Basic auth. More advanced (but equally easy) techniques for declaring deeply nested JSON models (thanks to Pydantic). GraphQL integration with Strawberry and other libraries. Many extra features (thanks to Starlette) as: WebSockets extremely easy tests based on HTTPX and pytest CORS Cookie Sessions ...and more. Performance &para; Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section Benchmarks . Dependencies &para; FastAPI depends on Pydantic and Starlette. standard Dependencies &para; When you install FastAPI with pip install "fastapi[standard]" it comes with the standard group of optional dependencies: Used by Pydantic: email-validator - for email validation. Used by Starlette: httpx - Required if you want to use the TestClient . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form "parsing" , with request.form() . Used by FastAPI: uvicorn - for the server that loads and serves your application. This includes uvicorn[standard] , which includes some dependencies (e.g. uvloop ) needed for high performance serving. fastapi-cli[standard] - to provide the fastapi command. This includes fastapi-cloud-cli , which allows you to deploy your FastAPI application to FastAPI Cloud . Without standard Dependencies &para; If you don't want to include the standard optional dependencies, you can install with pip install fastapi instead of pip install "fastapi[standard]" . Without fastapi-cloud-cli &para; If you want to install FastAPI with the standard dependencies but without the fastapi-cloud-cli , you can install with pip install "fastapi[standard-no-fastapi-cloud-cli]" . Additional Optional Dependencies &para; There are some additional dependencies you might want to install. Additional optional Pydantic dependencies: pydantic-settings - for settings management. pydantic-extra-types - for extra types to be used with Pydantic. Additional optional FastAPI dependencies: orjson - Required if you want to use ORJSONResponse . ujson - Required if you want to use UJSONResponse . License &para; This project is licensed under the terms of the MIT license. Back to top Next Features The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions Made with Material for MkDocs (confidence: 0.80)
- Finding from FastAPI Tutorial - GeeksforGeeks: --> FastAPI Tutorial - GeeksforGeeks --> Skip to content Tutorials Python Java DSA ML & Data Science Interview Corner Programming Languages Web Development CS Subjects DevOps Software and Tools School Learning Practice Coding Problems Courses DSA / Placements ML & Data Science Development Cloud / DevOps Programming Languages All Courses Tracks Languages Python C C++ Java Advanced Java SQL JavaScript Interview Preparation GfG 160 GfG 360 System Design Core Subjects Interview Questions Interview Puzzles Aptitude and Reasoning Data Science Python Data Analytics Complete Data Science Dev Skills Full-Stack Web Dev DevOps Software Testing CyberSecurity Tools Computer Fundamentals AI Tools MS Excel & Google Sheets MS Word & Google Docs Maths Maths For Computer Science Engineering Mathematics --> --> --> Python Tutorial Data Types Interview Questions Examples Quizzes DSA Python Data Science NumPy Pandas Practice Django Flask Projects Sign In --> Sign In &#x25B2; Open In App --> FastAPI Tutorial Last Updated : 10 Sep, 2025 Comments Improve Suggest changes Like Article Like --> Share --> Report --> Follow --> FastAPI is a modern, high-performance, Python web framework designed for building APIs quickly and efficiently. Built on Starlette (for web parts) and Pydantic (for data validation), it’s known for speed, ease of use and automatic generation of interactive API documentation with Swagger UI and ReDoc. Unlike Flask or Django, FastAPI is specifically optimized for building APIs with automatic type checking, validation and asynchronous support. This tutorial covers everything from setup and installation to advanced concepts like authentication and deployment. Interesting Facts about FastAPI Blazing Fast Performance: FastAPI is one of the fastest Python web frameworks, often compared to Node.js and Go. Its speed comes from using asynchronous programming (async/await), making it ideal for handling multiple requests at same time. Built on Starlette &amp; Pydantic: Starlette provides core web components such as routing, middleware and WebSockets whereas, Pydantic ensures powerful data validation and parsing, all using Python type hints. Automatic API Documentation: FastAPI automatically generates interactive API docs using Swagger UI and ReDoc, so developers can test endpoints without writing extra documentation. Type Hint Support: It leverages modern Python type hints for request and response validation, making your code cleaner, safer and easier to understand. Asynchronous by Default: Designed with async/await in mind, FastAPI supports highly concurrent applications, from chat apps to real-time dashboards. Strong Data Validation: With Pydantic models, data validation becomes effortless. Invalid inputs are caught early, ensuring reliable and secure APIs. Introduction to FastAPI This section covers the basics to get you started from introduction, installation to running your first FastAPI app and understanding differences. Introduction and Installation of FastAPI Differences Between Django, Flask and FastAPI REST APIs with FastAPI FastAPI is designed specifically for building powerful and efficient REST APIs. This section walks you through creating RESTful endpoints in FastAPI, handling requests and responses and building reliable APIs with ease. REST API with FastAPI Creating REST APIs in FastAPI Templates and Static Files in FastAPI FastAPI is primarily designed for building APIs, but it also supports serving HTML templates and static files which helps create complete web applications, not just APIs. This section covers how to work with templates and serve static files in FastAPI. Template and Static Files Working with Data and Files in FastAPI With built-in support for uploading files and the powerful validation features of Pydantic, one can easily manage user data and ensure it’s clean, reliable and secure. Handling File Uploads Pydantic Handling Request &amp; Response Data in FastAPI FastAPI makes it easy to define request bodies and response models with Pydantic, giving you automatic validation, type checking and clear API documentation. This section covers how to handle structured input and return reliable outputs. Request Body in FastAPI Response Model in FastAPI Middlewares in FastAPI Middlewares in FastAPI allow you to process requests and responses globally before they reach actual endpoints useful for tasks like authentication, error handling and logging. This section covers how to create custom middlewares and how to add logging middleware in FastAPI. Middlewares in FastAPI Custom Middlewares Database in FastAPI One can connect FastAPI with relational databases like SQLite using SQLAlchemy, or work with NoSQL solutions such as MongoDB using dedicated drivers. This section covers how to set up and manage database connections in FastAPI with SQLite and MongoDB. Database Integration in FastAPI using MongoDB Using SQLite with FastAPI Authentication in FastAPI FastAPI supports secure authentication and authorization using modern methods like OAuth2 and JWT. This section covers how to implement user login, permissions and protected routes with these approaches. Authentication and Authorization with FastAPI Advanced Topics in FastAPI FastAPI provides advanced features that make it ideal for production-ready applications. This section explores dependency injection, error handling and WebSockets, helping you build more powerful and scalable solutions. Dependency Injection in FastAPI Error Handling in FastAPI WebSockets in FastAPI Deployment &amp; Testing in FastAPI Deploying and testing are key steps to take your FastAPI app from development to production. This section shows how to deploy your app on Render and also how to test it effectively to ensure reliability. Deploy FastAPI using Render Testing FastAPI Application FastAPI Projects This section explores practical projects to help you apply FastAPI concepts in real-world scenarios, these projects will strengthen your hands-on experience. To-Do List App using FastAPI Login &amp; Registration System with JWT Chat App with WebSockets in FastAPI Applications of FastAPI FastAPI is widely used across industries due to its speed, simplicity, and strong validation features. Here are some common applications: RESTful APIs: Build reliable and scalable APIs for web and mobile applications. Data Validation Services: Use Pydantic models to clean and validate incoming data from users or external systems. File Upload &amp; Processing Systems: Ideal for applications like image hosting, resume upload portals and document management. Authentication &amp; Authorization: Implement secure login systems using JWT or OAuth2 for modern applications. Real-Time Applications: With WebSockets, build chat apps, live dashboards and collaborative tools. Machine Learning &amp; AI Integration: Serve ML models with FastAPI endpoints, enabling easy deployment of predictive services. Microservices: Perfect for building lightweight, independent services that communicate efficiently in distributed architectures. Comment H harshyeyi Follow Improve H harshyeyi Follow --> Like Article --> Improve Article Tags : Python FastAPI Explore Python Fundamentals Python Introduction 2 min read Input and Output in Python 4 min read Python Variables 5 min read Python Operators 4 min read Python Keywords 2 min read Python Data Types 7 min read Conditional Statements in Python 3 min read Loops in Python - For, While and Nested Loops 5 min read Python Functions 5 min read Recursion in Python 4 min read Python Lambda Functions 5 min read Python Data Structures Python String 5 min read Python Lists 4 min read Python Tuples 4 min read Python Dictionary 3 min read Python Sets 6 min read Python Arrays 7 min read List Comprehension in Python 4 min read Advanced Python Python OOP Concepts 11 min read Python Exception Handling 5 min read File Handling in Python 4 min read Python Database Tutorial 4 min read Python MongoDB Tutorial 2 min read Python MySQL 9 min read Python Packages 10 min read Python Modules 7 min read Python DSA Libraries 15 min read List of Python GUI Library and Packages 3 min read Data Science with Python NumPy Tutorial - Python Library 3 min read Pandas Tutorial 6 min read Matplotlib Tutorial 5 min read Python Seaborn Tutorial 15+ min read StatsModel Library- Tutorial 4 min read Learning Model Building in Scikit-learn 8 min read TensorFlow Tutorial 2 min read PyTorch Tutorial 6 min read Web Development with Python Flask Tutorial 8 min read Django Tutorial | Learn Django Framework 7 min read Django ORM - Inserting, Updating &amp; Deleting Data 4 min read Templating With Jinja2 in Flask 6 min read Django Templates 7 min read Python | Build a REST API using Flask 3 min read How to Create a basic API using Django Rest Framework ? 4 min read Python Practice Python Quiz 3 min read Python Coding Practice 1 min read Python Interview Questions and Answers 15+ min read Like Improve your Coding Skills with Practice Try It! --> &times; --> Corporate & Communications Address: A-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305) Registered Address: K 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305 Company About Us Legal Privacy Policy Contact Us Advertise with us GFG Corporate Solution Campus Training Program Explore POTD Job-A-Thon Blogs Nation Skill Up Tutorials Programming Languages DSA Web Technology AI, ML & Data Science DevOps CS Core Subjects Interview Preparation Software and Tools Courses IBM Certification DSA and Placements Web Development Programming Languages DevOps & Cloud GATE Trending Technologies Videos DSA Python Java C++ Web Development Data Science CS Subjects Preparation Corner Interview Corner Aptitude Puzzles GfG 160 System Design @GeeksforGeeks, Sanchhaya Education Private Limited , All rights reserved We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy &nbsp;Cookies are not collected in the GeeksforGeeks mobile applications. Got It ! --> --> Improvement Suggest changes Suggest Changes Help us improve. Share your suggestions to enhance the article. Contribute your expertise and make a difference in the GeeksforGeeks portal. Create Improvement Enhance the article with your expertise. Contribute to the GeeksforGeeks community and help create better learning resources for all. Suggest Changes min 4 words, max Words Limit:1000 Thank You! Your suggestions are valuable to us. --> What kind of Experience do you want to share? Tell us your type of experiences which can help other fellow Geeks for their future events and preparations. --> Interview Experiences Admission Experiences Career Journeys Work Experiences Campus Experiences Competitive Exam Experiences Can't choose a topic to write? click here for suggested topics Write and publish your own Article --> linked-list 9172 -> AI-ML-DS, 1789 -> python 4667 -> math) --> (confidence: 0.80)
- Finding from Home - FastAPI Tutorial: Home - FastAPI Tutorial FastAPI Tutorial Home Tutorial Objectives Project Setup Test setup Async Handlers Routes Postgres setup Models POST route GET routes PUT route DELETE route Additional Validation GET POST PUT DELETE Conclusion References Original tutorial: Other references: &nbsp; FastAPI Tutorial Docs &raquo; Home FastAPI documentation : https://fastapi.tiangolo.com This tutorial app source code (GitLab repo) : Please, for more comprehension access the repo https://gitlab.com/rhkina/fastapi as you follow this tutorial! FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. Historically, async work in Python has been nontrivial (though its API has rapidly improved since Python 3.4) particularly with Flask. Essentially, Flask (on most WSGI servers) is blocking by default - work triggered by a request to a particular endpoint will hold the server entirely until that request is completed. Instead, Flask (or rather, the WSGI server running it, like gunicorn or uWSGI ) achieve scaling by running multiple worker instances of the app in parallel, such that requests can be farmed to other workers while one is busy. Within a single worker, asynchronous work can be wrapped in a blocking call (the route function itself is still blocking), threaded (in newer versions of Flask), or farmed to a queue manager like Celery - but there isn’t a single consistent story where routes can cleanly handle asynchronous requests without additional tooling. FastAPI is designed from the ground up to run asynchronously - thanks to its underlying starlette ASGI framework, route functions default to running within an asynchronous event loop. With a good ASGI server (FastAPI is designed to couple to uvicorn , running on top of uvloop ) this can get us performance on par with fast asynchronous webservers in Go or Node, without losing the benefits of Python’s broader machine learning ecosystem. In contrast to messing with threads or Celery queues to achieve asynchronous execution in Flask, running an endpoint asynchronously is dead simple in FastAPI - we simply declare the route function as asynchronous (with async def ) and we’re ready to go! We can even do this if the route function isn’t conventionally asynchronous - that is, we don’t have any awaitable calls (like if the endpoint is running inference against an ML model). In fact, unless the endpoint is specifically performing a blocking IO operation (to a database, for example), it’s better to declare the function with async def (as blocking functions are actually punted to an external threadpool and then awaited anyhow). The key features are: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%.* Fewer bugs : Reduce about 40% of human (developer) induced errors.* Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . * estimation based on tests performed by internal development team. Tutorial Note : original blog to this tutorial from Michael Herman at testdriven.io . Objectives I have the following objectives with this repo: Develop an asynchronous RESTful API with Python and FastAPI Practice Test-Driven Development Test a FastAPI app with Pytest Interact with a Postgres database asynchronously Containerize FastAPI and Postgres inside a Docker container Parameterize test functions and mock functionality in tests with Pytest Document a RESTful API with Swagger/OpenAPI Project Setup Create the following structure: fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ └── main.py └── requirements.txt Add FastAPI and Uvicorn to the requirements file: fastapi==0.54.1 uvicorn==0.11.3 Within main.py, create a new instance of FastAPI and set up a sanity check route: from fastapi import FastAPI app = FastAPI() @app.get(&quot;/ping&quot;) def pong(): return {&quot;ping&quot;: &quot;pong!&quot;} Add the following lines in the Dockerfile (at src directory): # pull official base image FROM python:3.8.1-alpine # set work directory WORKDIR /usr/src/app # set environment variables ENV PYTHONDONTWRITEBYTECODE 1 ENV PYTHONUNBUFFERED 1 # copy requirements file COPY ./requirements.txt /usr/src/app/requirements.txt # install dependencies RUN set -eux \ &amp;&amp; apk add --no-cache --virtual .build-deps build-base \ libressl-dev libffi-dev gcc musl-dev python3-dev \ &amp;&amp; pip install --upgrade pip setuptools wheel \ &amp;&amp; pip install -r /usr/src/app/requirements.txt \ &amp;&amp; rm -rf /root/.cache/pip # copy project COPY . /usr/src/app/ Here we started an Alpine-based Docker image for Python 3.8.1 and set a working directory defining two environment variables: PYTHONDONTWRITEBYTECODE : Prevents Python from writing pyc files to disc (equivalent to python -B option) PYTHONUNBUFFERED : Prevents Python from buffering stdout and stderr (equivalent to python -u option) Finally, we copied over the requirements.txt file, installed some system-level dependencies, updated Pip, installed the requirements, and copied over the FastAPI app itself. Next, add the following to the docker-compose.yml file in the project root: version: '2.0' services: web: build: ./src command: uvicorn app.main:app --reload --workers 1 --host 0.0.0.0 --port 8000 volumes: - ./src/:/usr/src/app/ ports: - 8002:8000 So, when the container spins up, Uvicorn will run with the following settings: --reload enables auto-reload so the server will restart after changes are made to the code base. --workers 1 provides a single worker process. --host 0.0.0.0 defines the address to host the server on. --port 8000 defines the port to host the server on. app.main:app tells Uvicorn where it can find the FastAPI ASGI application - e.g., within the 'app' module, you'll find the ASGI app, app = FastAPI() , in the main.py file. Build the image and spin up the container: $ docker-compose up -d --build Navigate to http://localhost:8002/ping . You should see: {"ping":"pong!"} You'll also be able to view the interactive API documentation, powered by Swagger UI, at http://localhost:8002/docs : Test setup Create a tests folder in src and then add an __init__.py file to tests along with a test_main.py file: from starlette.testclient import TestClient from app.main import app client = TestClient(app) def test_ping(): response = client.get(&quot;/ping&quot;) assert response.status_code == 200 assert response.json() == {&quot;ping&quot;: &quot;pong!&quot;} Here, we imported Starlette's TestClient , which uses the Requests library to make requests against the FastAPI app. Add Pytest and Requests to requirements.txt : fastapi==0.54.1 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Update the image and then run the tests: $ docker-compose up -d --build $ docker-compose exec web pytest . You should see something like this: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_main.py . [100%] =========================================== 1 passed in 0.48s =========================================== Add a test_app Pytest fixture to a new file called src/tests/conftest.py : import pytest from starlette.testclient import TestClient from app.main import app @pytest.fixture(scope=&quot;module&quot;) def test_app(): client = TestClient(app) yield client # testing happens here Update the test_main.py file as well so that it uses the fixture: def test_ping(test_app): response = client.get(&quot;/ping&quot;) assert response.status_code == 200 assert response.json() == {&quot;ping&quot;: &quot;pong!&quot;} Your project structure should now look like this: fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ └── main.py ├── requirements.txt └── tests ├── __init__.py ├── conftest.py └── test_main.py Async Handlers Let's convert the synchronous handler over to an asynchronous one. Rather than having to go through the trouble of spinning up a task queue (like Celery or RQ) or utilizing threads, FastAPI makes it easy to deliver routes asynchronously. As long as you don't have any blocking I/O calls in the handler, you can simply declare the handler as asynchronous by just adding the async keyword like so (modify main.py ): @app.get(&quot;/ping&quot;) async def pong(): # some async operation could happen here # example: `notes = await get_all_notes()` return {&quot;ping&quot;: &quot;pong!&quot;} That's it! Update the handler in your code, and then make sure the tests still pass: $ docker-compose up -d --build $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_main.py . [100%] =========================================== 1 passed in 0.03s =========================================== Routes Next, let's set up the basic CRUD routes, following RESTful best practices: Endpoint HTTP Method CRUD Method Result /notes/ GET READ get all notes /notes/:id GET READ get a single note /notes/ POST CREATE add a note /notes/:id PUT UPDATE update a note /notes/:id DELETE DELETE delete a note For each route, we will: Write a test Run the test to ensure it fails (red) Write just enough code to get the test to pass (green) Refactor Before diving in, let's add some structure to better organize the CRUD routes with FastAPI's APIRouter . You can break up and modularize larger projects as well as apply versioning to your API with the APIRouter . If you're familiar with Flask, it is equivalent to a Blueprint . Add a new folder called api to the app folder, and add an __init__.py file to the newly created folder. Now we can move the /ping route to a new file called src/app/api/ping.py : from fastapi import APIRouter router = APIRouter() @router.get(&quot;/ping&quot;) async def pong(): # some async operation could happen here # example: `notes = await get_all_notes()` return {&quot;ping&quot;: &quot;pong!&quot;} Then, update main.py like so to remove the old route and wire the router up to our main app: from fastapi import FastAPI from app.api import ping app = FastAPI() app.include_router(ping.router) Rename test_main.py to test_ping.py . Make sure http://localhost:8002/ping and http://localhost:8002/docs still work. Also, be sure the tests still pass before moving on. $ docker-compose up -d --build $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_ping.py . [100%] =========================================== 1 passed in 0.04s =========================================== Postgres setup To configure Postgres, we'll need to add a new service to the docker-compose.yml file, add the appropriate environment variables, and install asyncpg . First, add a new service called db to docker-compose.yml : version: '2.0' services: web: build: ./src command: uvicorn app.main:app --reload --workers 1 --host 0.0.0.0 --port 8000 volumes: - ./src/:/usr/src/app/ ports: - 8002:8000 environment: - DATABASE_URL=postgresql://hello_fastapi:hello_fastapi@db/hello_fastapi_dev db: image: postgres:12.1-alpine volumes: - postgres_data:/var/lib/postgresql/data/ environment: - POSTGRES_USER=hello_fastapi - POSTGRES_PASSWORD=hello_fastapi - POSTGRES_DB=hello_fastapi_dev volumes: postgres_data: To persist the data beyond the life of the container we configured a volume. This config will bind postgres_data to the /var/lib/postgresql/data/ directory in the container. We also added an environment key to define a name for the default database and set a username and password. Review the "Environment Variables" section of the Postgres Docker Hub page for more info. Update the Dockerfile to install the appropriate packages required for asyncpg : # pull official base image FROM python:3.8.1-alpine # set work directory WORKDIR /usr/src/app # set environment variables ENV PYTHONDONTWRITEBYTECODE 1 ENV PYTHONUNBUFFERED 1 # copy requirements file COPY ./requirements.txt /usr/src/app/requirements.txt # install dependencies RUN set -eux \ &amp;&amp; apk add --no-cache --virtual .build-deps build-base \ libressl-dev libffi-dev gcc musl-dev python3-dev \ postgresql-dev \ &amp;&amp; pip install --upgrade pip setuptools wheel \ &amp;&amp; pip install -r /usr/src/app/requirements.txt \ &amp;&amp; rm -rf /root/.cache/pip # copy project COPY . /usr/src/app/ Add asyncpg to src/requirements.txt : asyncpg==0.20.0 fastapi==0.54.1 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Next, add a db.py file to src/app : import os from databases import Database from sqlalchemy import create_engine, MetaData DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;) # SQLAlchemy engine = create_engine(DATABASE_URL) metadata = MetaData() # databases query builder database = Database(DATABASE_URL) Here, using the database URI and credentials that we just configured in the Docker Compose file, we created a SQLAlchemy engine (used for communicating with the database) along with a Metadata instance (used for creating the database schema). We also created a new Database instance from databases . databases is an async SQL query builder that works on top of the SQLAlchemy Core expression language. It supports the following methods: database.fetch_all(query) database.fetch_one(query) database.iterate(query) database.execute(query) database.execute_many(query) Review the Async SQL (Relational) Databases guide and the Starlette Database docs for more details on working with databases asynchronously. Update the requirements.txt : asyncpg==0.20.0 databases[postgresql]==0.2.6 fastapi==0.54.1 SQLAlchemy==1.3.16 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Models SQLAlchemy Model Add a notes model to src/app/db.py : import os from sqlalchemy import (Column, DateTime, Integer, MetaData, String, Table, create_engine) from sqlalchemy.sql import func from databases import Database DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;) # SQLAlchemy engine = create_engine(DATABASE_URL) metadata = MetaData() notes = Table( &quot;notes&quot;, metadata, Column(&quot;id&quot;, Integer, primary_key=True), Column(&quot;title&quot;, String(50)), Column(&quot;description&quot;, String(50)), Column(&quot;created_date&quot;, DateTime, default=func.now(), nullable=False), ) # databases query builder database = Database(DATABASE_URL) Wire up the database and the model in main.py and add startup and shutdown event handlers for connecting to and disconnecting from the database: from fastapi import FastAPI from app.api import notes, ping from app.db import engine, metadata, database metadata.create_all(engine) app = FastAPI() @app.on_event(&quot;startup&quot;) async def startup(): await database.connect() @app.on_event(&quot;shutdown&quot;) async def shutdown(): await database.disconnect() app.include_router(ping.router) Build the new image and spin up the two containers: $ docker-compose up -d --build Ensure the notes table was created: $ docker-compose exec db psql --username=hello_fastapi --dbname=hello_fastapi_dev psql (12.1) Type &quot;help&quot; for help. hello_fastapi_dev=# \l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges -------------------+---------------+----------+------------+------------+--------------------------------- hello_fastapi_dev | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | postgres | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | template0 | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | =c/hello_fastapi + | | | | | hello_fastapi=CTc/hello_fastapi template1 | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | =c/hello_fastapi + | | | | | hello_fastapi=CTc/hello_fastapi (4 rows) hello_fastapi_dev=# \c hello_fastapi_dev You are now connected to database &quot;hello_fastapi_dev&quot; as user &quot;hello_fastapi&quot;. hello_fastapi_dev=# \dt List of relations Schema | Name | Type | Owner --------+-------+-------+--------------- public | notes | table | hello_fastapi (1 row) hello_fastapi_dev=# \q Pydantic model First time using pydantic? View pydantic Overview for more details. Create a NoteSchema pydantic model with two required fields, title and description , in a new file called models.py in src/app/api : from pydantic import BaseModel class NoteSchema(BaseModel): title: str description: str NoteSchema will be used for validating the payloads for creating and updating notes. POST route We will break the normal TDD flow for this route in order to establish the coding pattern that we'll use for the remaining routes. Code Create a new file called notes.py in the src/app/api folder: from app.api import crud from app.api.models import NoteDB, NoteSchema from fastapi import APIRouter, HTTPException router = APIRouter() @router.post(&quot;/&quot;, response_model=NoteDB, status_code=201) async def create_note(payload: NoteSchema): note_id = await crud.post(payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object Here, we defined a handler that expects a payload, payload: NoteSchema , with a title and a description . Essentially, when the route is hit with a POST request, FastAPI will read the body of the request and validate the data: - If valid, the data will be available in the payload parameter. FastAPI also generates JSON Schema definitions that are then used to automatically generate the OpenAPI schema and the API documentation. - If invalid, an error is immediately returned. Review the Request Body for more info. Note that we used the async declaration here since the database communication will be asynchronous. In other words, there are no blocking I/O operations in the handler. Next, create a new file called crud.py in the src/app/api folder: from app.api.models import NoteSchema from app.db import notes, database async def post(payload: NoteSchema): query = notes.insert().values(title=payload.title, description=payload.description) return await database.execute(query=query) We added a utility function called post for creating new notes that takes a payload object and then: Creates a SQLAlchemy insert object expression query. Executes the query and returns the generated ID. Next, we need to define a new pydantic model for use as the response_model : @router.post("/", response_model=NoteDB, status_code=201) Update models.py like so: from pydantic import BaseModel class NoteSchema(BaseModel): title: str description: str class NoteDB(NoteSchema): id: int The NoteDB model inherits from the NoteSchema model, adding an id field. Wire up the new router in main.py : from app.api import notes, ping from app.db import database, engine, metadata from fastapi import FastAPI metadata.create_all(engine) app = FastAPI() @app.on_event(&quot;startup&quot;) async def startup(): await database.connect() @app.on_event(&quot;shutdown&quot;) async def shutdown(): await database.disconnect() app.include_router(ping.router) app.include_router(notes.router, prefix=&quot;/notes&quot;, tags=[&quot;notes&quot;]) Take note of the prefix URL along with the notes tag , which will be applied to the OpenAPI schema (for grouping operations ). Test it out with curl or HTTPie : $ http --json POST http://localhost:8002/notes/ title=foo description=bar You should see something like: HTTP/1.1 201 Created content-length: 42 content-type: application/json date: Sun, 12 Apr 2020 04:39:56 GMT server: uvicorn { &quot;description&quot;: &quot;bar&quot;, &quot;id&quot;: 1, &quot;title&quot;: &quot;foo&quot; } You can also interact with the endpoint at http://localhost:8002/docs/ . Test Add the following test to a new test file called src/tests/test_notes.py : import json import pytest from app.api import crud def test_create_note(test_app, monkeypatch): test_request_payload = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} test_response_payload = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_post(payload): return 1 monkeypatch.setattr(crud, &quot;post&quot;, mock_post) response = test_app.post(&quot;/notes/&quot;, data=json.dumps(test_request_payload),) assert response.status_code == 201 assert response.json() == test_response_payload def test_create_note_invalid_json(test_app): response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;something&quot;})) assert response.status_code == 422 This test uses the Pytest monkeypatch fixture to mock out the crud.post function. We then asserted that the endpoint responds with the expected status codes and response body. $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 3 items tests/test_notes.py .. [ 66%] tests/test_ping.py . [100%] =========================================== 3 passed in 0.05s =========================================== Now we can configure the remaining CRUD routes using Test-Driven Development. fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ ├── api │ │ ├── __init__.py │ │ ├── crud.py │ │ ├── models.py │ │ ├── notes.py │ │ └── ping.py │ ├── db.py │ └── main.py ├── requirements.txt └── tests ├── __init__.py ├── conftest.py ├── test_notes.py └── test_ping.py GET routes GET one note Test Add the following tests (inside test_notes.py ): def test_read_note(test_app, monkeypatch): test_data = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/1&quot;) assert response.status_code == 200 assert response.json() == test_data def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; Run tests: docker-compose exec web pytest . They should fail: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 3 items tests/test_notes.py .. [ 66%] tests/test_ping.py . [100%] =========================================== 3 passed in 0.05s =========================================== (base) rhkina@rhkina-ThinkPad-T440:~/Workspace/fastapi$ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 5 items tests/test_notes.py ..FF [ 80%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ____________________________________________ test_read_note _____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f8c5297e8b0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8c5297e6d0&gt; def test_read_note(test_app, monkeypatch): test_data = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_get(id): return test_data &gt; monkeypatch.setattr(crud, &quot;get&quot;, mock_get) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get' tests/test_notes.py:29: AttributeError ______________________________________ test_read_note_incorrect_id ______________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f8c5297e8b0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8c52615e20&gt; def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None &gt; monkeypatch.setattr(crud, &quot;get&quot;, mock_get) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get' tests/test_notes.py:39: AttributeError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/app... FAILED tests/test_notes.py::test_read_note_incorrect_id - AttributeError: &lt;module 'app.api.crud' from ... ====================================== 2 failed, 3 passed in 0.13s ====================================== Code Add the handler (inside notes.py ): @router.get(&quot;/{id}/&quot;, response_model=NoteDB) async def read_note(id: int): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) return note Here, instead of taking a payload, the handler requires an id , an integer, which will come from the path -- i.e., /notes/5/ . Add the get utility function to crud.py : async def get(id: int): query = notes.select().where(id == notes.c.id) return await database.fetch_one(query=query) Before moving on, ensure the tests pass and manually test the new endpoint in the browser, with curl or HTTPie, and/or via the API documentation. GET all notes Test Next, add a test for reading all notes: def test_read_all_notes(test_app, monkeypatch): test_data = [ {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1}, {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 2}, ] async def mock_get_all(): return test_data monkeypatch.setattr(crud, &quot;get_all&quot;, mock_get_all) response = test_app.get(&quot;/notes/&quot;) assert response.status_code == 200 assert response.json() == test_data Again, make sure the test fails. docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 6 items tests/test_notes.py ....F [ 83%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ __________________________________________ test_read_all_notes __________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7fefa6ffa8e0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7fefa6ffadf0&gt; def test_read_all_notes(test_app, monkeypatch): test_data = [ {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1}, {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 2}, ] async def mock_get_all(): return test_data &gt; monkeypatch.setattr(crud, &quot;get_all&quot;, mock_get_all) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get_all' tests/test_notes.py:54: AttributeError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_all_notes - AttributeError: &lt;module 'app.api.crud' from '/usr/sr... ====================================== 1 failed, 5 passed in 0.14s ====================================== Code Handler Add the following code to notes.py : @router.get(&quot;/&quot;, response_model=List[NoteDB]) async def read_all_notes(): return await crud.get_all() And import List from Python's typing module (include at the top of the notes.py ): from typing import List The response_model is a List with a NoteDB subtype. Util Add the CRUD util at crud.py : async def get_all(): query = notes.select() return await database.fetch_all(query=query) Make sure the automated tests pass now. Manually test this endpoint as well. docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 6 items tests/test_notes.py ..... [ 83%] tests/test_ping.py . [100%] =========================================== 6 passed in 0.08s =========================================== PUT route Test Add the code to the test_notes.py : def test_update_note(test_app, monkeypatch): test_update_data = {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 1} async def mock_get(id): return True monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_put(id, payload): return 1 monkeypatch.setattr(crud, &quot;put&quot;, mock_put) response = test_app.put(&quot;/notes/1/&quot;, data=json.dumps(test_update_data)) assert response.status_code == 200 assert response.json() == test_update_data @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) assert response.status_code == status_code This test uses the Pytest parametrize decorator to parametrize the arguments for the test_update_note_invalid function. Run tests: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 10 items tests/test_notes.py .....FFFF [ 90%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ___________________________________________ test_update_note ____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04899846a0&gt; def test_update_note(test_app, monkeypatch): test_update_data = {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 1} async def mock_get(id): return True monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_put(id, payload): return 1 &gt; monkeypatch.setattr(crud, &quot;put&quot;, mock_put) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'put' tests/test_notes.py:71: AttributeError _______________________________ test_update_note_invalid[1-payload0-422] ________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f0489976100&gt;, id = 1, payload = {} status_code = 422 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 422 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError _______________________________ test_update_note_invalid[1-payload1-422] ________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04898577c0&gt;, id = 1 payload = {'description': 'bar'}, status_code = 422 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 422 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError ______________________________ test_update_note_invalid[999-payload2-404] _______________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04898666d0&gt;, id = 999 payload = {'description': 'bar', 'title': 'foo'}, status_code = 404 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 404 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_update_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/a... FAILED tests/test_notes.py::test_update_note_invalid[1-payload0-422] - assert 405 == 422 FAILED tests/test_notes.py::test_update_note_invalid[1-payload1-422] - assert 405 == 422 FAILED tests/test_notes.py::test_update_note_invalid[999-payload2-404] - assert 405 == 404 ====================================== 4 failed, 6 passed in 0.21s ====================================== Code Handler ( notes.py ) @router.put(&quot;/{id}/&quot;, response_model=NoteDB) async def update_note(id: int, payload: NoteSchema): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) note_id = await crud.put(id, payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object Util ( crud.py ) async def put(id: int, payload: NoteSchema): query = ( notes .update() .where(id == notes.c.id) .values(title=payload.title, description=payload.description) .returning(notes.c.id) ) return await database.execute(query=query) Run tests: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 10 items tests/test_notes.py ......... [ 90%] tests/test_ping.py . [100%] ========================================== 10 passed in 0.12s =========================================== Manually test this endpoint as well. DELETE route Test In test_notes.py add: def test_remove_note(test_app, monkeypatch): test_data = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_delete(id): return id monkeypatch.setattr(crud, &quot;delete&quot;, mock_delete) response = test_app.delete(&quot;/notes/1/&quot;) assert response.status_code == 200 assert response.json() == test_data def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; Run tests and make sure you get errors: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py .........FF [ 91%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ___________________________________________ test_remove_note ____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f30ec5cb730&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f30ec5900a0&gt; def test_remove_note(test_app, monkeypatch): test_data = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_delete(id): return id &gt; monkeypatch.setattr(crud, &quot;delete&quot;, mock_delete) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'delete' tests/test_notes.py:106: AttributeError _____________________________________ test_remove_note_incorrect_id _____________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f30ec5cb730&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f30ec5da970&gt; def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) &gt; assert response.status_code == 404 E assert 405 == 404 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:120: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_remove_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/a... FAILED tests/test_notes.py::test_remove_note_incorrect_id - assert 405 == 404 ===================================== 2 failed, 10 passed in 0.19s ====================================== Code Handler ( notes.py ) @router.delete(&quot;/{id}/&quot;, response_model=NoteDB) async def delete_note(id: int): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) await crud.delete(id) return note Util ( crud.py ) async def delete(id: int): query = notes.delete().where(id == notes.c.id) return await database.execute(query=query) Make sure all tests pass: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ........... [ 91%] tests/test_ping.py . [100%] ========================================== 12 passed in 0.13s =========================================== Additional Validation Let's add some additional validation to routes, checking: The id is greater than 0 for reading a single note, updating a note, and deleting a note. The title and description fields from the request payloads must have lengths &gt;= 3 and &lt;= 50 for adding and updating a note. GET Update the test_read_note_incorrect_id test in test_notes.py : def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.get(&quot;/notes/0&quot;) assert response.status_code == 422 The test should fail: docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ...F....... [ 91%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ______________________________________ test_read_note_incorrect_id ______________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f5d02bfac10&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f5d02bfa280&gt; def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.get(&quot;/notes/0&quot;) &gt; assert response.status_code == 422 E assert 404 == 422 E + where 404 = &lt;Response [404]&gt;.status_code tests/test_notes.py:46: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_note_incorrect_id - assert 404 == 422 ===================================== 1 failed, 11 passed in 0.19s ====================================== Update the handler (in notes.py ): @router.get(&quot;/{id}/&quot;, response_model=NoteDB) async def read_note(id: int = Path(..., gt=0),): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) return note Make sure to import Path (at the top of notes.py ); from fastapi import APIRouter, HTTPException, Path So, we added the following metadata to the parameter with Path : 1. ... - the value is required ( Ellipsis ) 2. gt - the value must be greater than 0 The tests should pass: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ........... [ 91%] tests/test_ping.py . [100%] ========================================== 12 passed in 0.13s =========================================== Try out the API documentation as well: POST Update the test_create_note_invalid_json test ( test_notes.py ): def test_create_note_invalid_json(test_app): response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;something&quot;})) assert response.status_code == 422 response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;1&quot;, &quot;description&quot;: &quot;2&quot;})) assert response.status_code == 422 Run the test and you should see the error (now on, I will not show the command and the result). To get the test to pass, update the NoteSchema (in models.py ) like so: class NoteSchema(BaseModel): title: str = Field(..., min_length=3, max_length=50) description: str = Field(..., min_length=3, max_length=50) As we added additional validation to the pydantic model with Field , add the import (in the same models.py file): from pydantic import BaseModel, Field PUT Add three more scenarios to test_update_note_invalid ( test_notes.py ): @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], [1, {&quot;title&quot;: &quot;1&quot;, &quot;description&quot;: &quot;bar&quot;}, 422], [1, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;1&quot;}, 422], [0, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 422], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) assert response.status_code == status_code Handler notes.py : @router.put(&quot;/{id}/&quot;, response_model=NoteDB) async def update_note(payload: NoteSchema, id: int = Path(..., gt=0),): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) note_id = await crud.put(id, payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object DELETE Test ( test_notes.py ): def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.delete(&quot;/notes/0/&quot;) assert response.status_code == 422 Test Error : ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 15 items tests/test_notes.py .............F [ 93%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ _____________________________________ test_remove_note_incorrect_id _____________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7ff9374014f0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7ff9373b4460&gt; def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.delete(&quot;/notes/0/&quot;) &gt; assert response.status_code == 422 E assert 404 == 422 E + where 404 = &lt;Response [404]&gt;.status_code tests/test_notes.py:133: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_remove_note_incorrect_id - assert 404 == 422 ===================================== 1 failed, 14 passed in 0.23s ====================================== Handler ( notes.py ): @router.delete(&quot;/{id}/&quot;, response_model=NoteDB) async def delete_note(id: int = Path(..., gt=0)): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) await crud.delete(id) return note The tests should pass: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 15 items tests/test_notes.py .............. [ 93%] tests/test_ping.py . [100%] ========================================== 15 passed in 0.16s =========================================== Conclusion FastAPI is an awesome asynchronous Python micro framework! With Flask-like simplicity, it is easy and fun to update your Flask RESTful API to asynchronous mode. Hope you have enjoyed! References Original tutorial: Herman, Michael - Developing and Testing an Asynchronous API with FastAPI and Pytest Other references: FastAPI Official Documentation - https://fastapi.tiangolo.com/ Uvicorn Official Documentation - https://fastapi.tiangolo.com/ Starlette Official Documentation - https://www.starlette.io/ Pydantic Official Documentation - https://pydantic-docs.helpmanual.io/ Built with MkDocs using a theme provided by Read the Docs . (confidence: 0.80)

## Metadata

- **Strategy**: Comprehensive
- **Depth**: 1
- **Sources**: 3
- **Diversity Score**: 1.00
- **Confidence**: High

## Findings

### Finding 1

Finding from FastAPI: FastAPI Skip to content Follow @fastapi on X (Twitter) to stay updated Follow FastAPI on LinkedIn to stay updated Subscribe to the FastAPI and friends newsletter 🎉 sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor sponsor FastAPI FastAPI en - English de - Deutsch es - español fa - فارسی fr - français ja - 日本語 ko - 한국어 pt - português ru - русский язык tr - Türkçe uk - українська мова vi - Tiếng Việt zh - 简体中文 zh-hant - 繁體中文 😉 Initializing search fastapi/fastapi FastAPI Features Learn Reference FastAPI People Resources About Release Notes FastAPI fastapi/fastapi FastAPI FastAPI Table of contents Sponsors Opinions Typer , the FastAPI of CLIs Requirements Installation Example Create it Run it Check it Interactive API docs Alternative API docs Example upgrade Interactive API docs upgrade Alternative API docs upgrade Recap Performance Dependencies standard Dependencies Without standard Dependencies Without fastapi-cloud-cli Additional Optional Dependencies License Features Learn Learn Python Types Intro Concurrency and async / await Environment Variables Virtual Environments Tutorial - User Guide Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Query Parameter Models Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Cookie Parameter Models Header Parameter Models Response Model - Return Type Extra Models Response Status Code Form Data Form Models Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: lifespan and startup - shutdown Testing Dependencies with Overrides Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generating SDKs FastAPI CLI Deployment Deployment About FastAPI versions About HTTPS Run a Server Manually Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Uvicorn with Workers FastAPI in Containers - Docker How To - Recipes How To - Recipes General - How To - Recipes GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Testing a Database Reference Reference FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient FastAPI People Resources Resources Help FastAPI - Get Help Development - Contributing Full Stack FastAPI Template External Links and Articles FastAPI and friends newsletter Repository Management Tasks About About Alternatives, Inspiration and Comparisons History, Design and Future Benchmarks Repository Management Release Notes Table of contents Sponsors Opinions Typer , the FastAPI of CLIs Requirements Installation Example Create it Run it Check it Interactive API docs Alternative API docs Example upgrade Interactive API docs upgrade Alternative API docs upgrade Recap Performance Dependencies standard Dependencies Without standard Dependencies Without fastapi-cloud-cli Additional Optional Dependencies License FastAPI &para; FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation : https://fastapi.tiangolo.com Source Code : https://github.com/fastapi/fastapi FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. The key features are: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%. * Fewer bugs : Reduce about 40% of human (developer) induced errors. * Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . * estimation based on tests on an internal development team, building production applications. Sponsors &para; Other sponsors Opinions &para; " [...] I'm using FastAPI a ton these days. [...] I'm actually planning to use it for all of my team's ML services at Microsoft . Some of them are getting integrated into the core Windows product and some Office products. " Kabir Khan - Microsoft (ref) " We adopted the FastAPI library to spawn a REST server that can be queried to obtain predictions . [for Ludwig] " Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala - Uber (ref) " Netflix is pleased to announce the open-source release of our crisis management orchestration framework: Dispatch ! [built with FastAPI ] " Kevin Glisson, Marc Vilanova, Forest Monsen - Netflix (ref) " I’m over the moon excited about FastAPI . It’s so fun! " Brian Okken - Python Bytes podcast host (ref) " Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted Hug to be - it's really inspiring to see someone build that. " Timothy Crosley - Hug creator (ref) " If you're looking to learn one modern framework for building REST APIs, check out FastAPI [...] It's fast, easy to use and easy to learn [...] " " We've switched over to FastAPI for our APIs [...] I think you'll like it [...] " Ines Montani - Matthew Honnibal - Explosion AI founders - spaCy creators (ref) - (ref) " If anyone is looking to build a production Python API, I would highly recommend FastAPI . It is beautifully designed , simple to use and highly scalable , it has become a key component in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer. " Deon Pillsbury - Cisco (ref) Typer , the FastAPI of CLIs &para; If you are building a CLI app to be used in the terminal instead of a web API, check out Typer . Typer is FastAPI's little sibling. And it's intended to be the FastAPI of CLIs . ⌨️ 🚀 Requirements &para; FastAPI stands on the shoulders of giants: Starlette for the web parts. Pydantic for the data parts. Installation &para; Create and activate a virtual environment and then install FastAPI: $ pip install &quot;fastapi[standard]&quot; ---&gt; 100% Note : Make sure you put "fastapi[standard]" in quotes to ensure it works in all terminals. Example &para; Create it &para; Create a file main.py with: from typing import Union from fastapi import FastAPI app = FastAPI () @app . get ( &quot;/&quot; ) def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } Or use async def ... If your code uses async / await , use async def : from typing import Union from fastapi import FastAPI app = FastAPI () @app . get ( &quot;/&quot; ) async def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) async def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } Note : If you don't know, check the "In a hurry?" section about async and await in the docs . Run it &para; Run the server with: $ fastapi dev main.py ╭────────── FastAPI CLI - Development mode ───────────╮ │ │ │ Serving at: http://127.0.0.1:8000 │ │ │ │ API docs: http://127.0.0.1:8000/docs │ │ │ │ Running in development mode, for production use: │ │ │ │ fastapi run │ │ │ ╰─────────────────────────────────────────────────────╯ INFO: Will watch for changes in these directories: [&#39;/home/user/code/awesomeapp&#39;] INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [2248755] using WatchFiles INFO: Started server process [2248757] INFO: Waiting for application startup. INFO: Application startup complete. About the command fastapi dev main.py ... The command fastapi dev reads your main.py file, detects the FastAPI app in it, and starts a server using Uvicorn . By default, fastapi dev will start with auto-reload enabled for local development. You can read more about it in the FastAPI CLI docs . Check it &para; Open your browser at http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { &quot;item_id&quot; : 5 , &quot;q&quot; : &quot;somequery&quot; } You already created an API that: Receives HTTP requests in the paths / and /items/{item_id} . Both paths take GET operations (also known as HTTP methods ). The path /items/{item_id} has a path parameter item_id that should be an int . The path /items/{item_id} has an optional str query parameter q . Interactive API docs &para; Now go to http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by Swagger UI ): Alternative API docs &para; And now, go to http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by ReDoc ): Example upgrade &para; Now modify the file main.py to receive a body from a PUT request. Declare the body using standard Python types, thanks to Pydantic. from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI () class Item ( BaseModel ): name : str price : float is_offer : Union [ bool , None ] = None @app . get ( &quot;/&quot; ) def read_root (): return { &quot;Hello&quot; : &quot;World&quot; } @app . get ( &quot;/items/ {item_id} &quot; ) def read_item ( item_id : int , q : Union [ str , None ] = None ): return { &quot;item_id&quot; : item_id , &quot;q&quot; : q } @app . put ( &quot;/items/ {item_id} &quot; ) def update_item ( item_id : int , item : Item ): return { &quot;item_name&quot; : item . name , &quot;item_id&quot; : item_id } The fastapi dev server should reload automatically. Interactive API docs upgrade &para; Now go to http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API: Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade &para; And now, go to http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body: Recap &para; In summary, you declare once the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python . For example, for an int : item_id : int or for a more complex Item model: item : Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str , int , float , bool , list , etc). datetime objects. UUID objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example, FastAPI will: Validate that there is an item_id in the path for GET and PUT requests. Validate that the item_id is of type int for GET and PUT requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named q (as in http://127.0.0.1:8000/items/foo?q=somequery ) for GET requests. As the q parameter is declared with = None , it is optional. Without the None it would be required (as is the body in the case with PUT ). For PUT requests to /items/{item_id} , read the body as JSON: Check that it has a required attribute name that should be a str . Check that it has a required attribute price that has to be a float . Check that it has an optional attribute is_offer , that should be a bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return { &quot;item_name&quot; : item . name , &quot;item_id&quot; : item_id } ...from: ... &quot;item_name&quot; : item . name ... ...to: ... &quot;item_price&quot; : item . price ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of parameters from other different places as: headers , cookies , form fields and files . How to set validation constraints as maximum_length or regex . A very powerful and easy to use Dependency Injection system. Security and authentication, including support for OAuth2 with JWT tokens and HTTP Basic auth. More advanced (but equally easy) techniques for declaring deeply nested JSON models (thanks to Pydantic). GraphQL integration with Strawberry and other libraries. Many extra features (thanks to Starlette) as: WebSockets extremely easy tests based on HTTPX and pytest CORS Cookie Sessions ...and more. Performance &para; Independent TechEmpower benchmarks show FastAPI applications running under Uvicorn as one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section Benchmarks . Dependencies &para; FastAPI depends on Pydantic and Starlette. standard Dependencies &para; When you install FastAPI with pip install "fastapi[standard]" it comes with the standard group of optional dependencies: Used by Pydantic: email-validator - for email validation. Used by Starlette: httpx - Required if you want to use the TestClient . jinja2 - Required if you want to use the default template configuration. python-multipart - Required if you want to support form "parsing" , with request.form() . Used by FastAPI: uvicorn - for the server that loads and serves your application. This includes uvicorn[standard] , which includes some dependencies (e.g. uvloop ) needed for high performance serving. fastapi-cli[standard] - to provide the fastapi command. This includes fastapi-cloud-cli , which allows you to deploy your FastAPI application to FastAPI Cloud . Without standard Dependencies &para; If you don't want to include the standard optional dependencies, you can install with pip install fastapi instead of pip install "fastapi[standard]" . Without fastapi-cloud-cli &para; If you want to install FastAPI with the standard dependencies but without the fastapi-cloud-cli , you can install with pip install "fastapi[standard-no-fastapi-cloud-cli]" . Additional Optional Dependencies &para; There are some additional dependencies you might want to install. Additional optional Pydantic dependencies: pydantic-settings - for settings management. pydantic-extra-types - for extra types to be used with Pydantic. Additional optional FastAPI dependencies: orjson - Required if you want to use ORJSONResponse . ujson - Required if you want to use UJSONResponse . License &para; This project is licensed under the terms of the MIT license. Back to top Next Features The FastAPI trademark is owned by @tiangolo and is registered in the US and across other regions Made with Material for MkDocs

**Confidence**: 0.80

### Finding 2

Finding from FastAPI Tutorial - GeeksforGeeks: --> FastAPI Tutorial - GeeksforGeeks --> Skip to content Tutorials Python Java DSA ML & Data Science Interview Corner Programming Languages Web Development CS Subjects DevOps Software and Tools School Learning Practice Coding Problems Courses DSA / Placements ML & Data Science Development Cloud / DevOps Programming Languages All Courses Tracks Languages Python C C++ Java Advanced Java SQL JavaScript Interview Preparation GfG 160 GfG 360 System Design Core Subjects Interview Questions Interview Puzzles Aptitude and Reasoning Data Science Python Data Analytics Complete Data Science Dev Skills Full-Stack Web Dev DevOps Software Testing CyberSecurity Tools Computer Fundamentals AI Tools MS Excel & Google Sheets MS Word & Google Docs Maths Maths For Computer Science Engineering Mathematics --> --> --> Python Tutorial Data Types Interview Questions Examples Quizzes DSA Python Data Science NumPy Pandas Practice Django Flask Projects Sign In --> Sign In &#x25B2; Open In App --> FastAPI Tutorial Last Updated : 10 Sep, 2025 Comments Improve Suggest changes Like Article Like --> Share --> Report --> Follow --> FastAPI is a modern, high-performance, Python web framework designed for building APIs quickly and efficiently. Built on Starlette (for web parts) and Pydantic (for data validation), it’s known for speed, ease of use and automatic generation of interactive API documentation with Swagger UI and ReDoc. Unlike Flask or Django, FastAPI is specifically optimized for building APIs with automatic type checking, validation and asynchronous support. This tutorial covers everything from setup and installation to advanced concepts like authentication and deployment. Interesting Facts about FastAPI Blazing Fast Performance: FastAPI is one of the fastest Python web frameworks, often compared to Node.js and Go. Its speed comes from using asynchronous programming (async/await), making it ideal for handling multiple requests at same time. Built on Starlette &amp; Pydantic: Starlette provides core web components such as routing, middleware and WebSockets whereas, Pydantic ensures powerful data validation and parsing, all using Python type hints. Automatic API Documentation: FastAPI automatically generates interactive API docs using Swagger UI and ReDoc, so developers can test endpoints without writing extra documentation. Type Hint Support: It leverages modern Python type hints for request and response validation, making your code cleaner, safer and easier to understand. Asynchronous by Default: Designed with async/await in mind, FastAPI supports highly concurrent applications, from chat apps to real-time dashboards. Strong Data Validation: With Pydantic models, data validation becomes effortless. Invalid inputs are caught early, ensuring reliable and secure APIs. Introduction to FastAPI This section covers the basics to get you started from introduction, installation to running your first FastAPI app and understanding differences. Introduction and Installation of FastAPI Differences Between Django, Flask and FastAPI REST APIs with FastAPI FastAPI is designed specifically for building powerful and efficient REST APIs. This section walks you through creating RESTful endpoints in FastAPI, handling requests and responses and building reliable APIs with ease. REST API with FastAPI Creating REST APIs in FastAPI Templates and Static Files in FastAPI FastAPI is primarily designed for building APIs, but it also supports serving HTML templates and static files which helps create complete web applications, not just APIs. This section covers how to work with templates and serve static files in FastAPI. Template and Static Files Working with Data and Files in FastAPI With built-in support for uploading files and the powerful validation features of Pydantic, one can easily manage user data and ensure it’s clean, reliable and secure. Handling File Uploads Pydantic Handling Request &amp; Response Data in FastAPI FastAPI makes it easy to define request bodies and response models with Pydantic, giving you automatic validation, type checking and clear API documentation. This section covers how to handle structured input and return reliable outputs. Request Body in FastAPI Response Model in FastAPI Middlewares in FastAPI Middlewares in FastAPI allow you to process requests and responses globally before they reach actual endpoints useful for tasks like authentication, error handling and logging. This section covers how to create custom middlewares and how to add logging middleware in FastAPI. Middlewares in FastAPI Custom Middlewares Database in FastAPI One can connect FastAPI with relational databases like SQLite using SQLAlchemy, or work with NoSQL solutions such as MongoDB using dedicated drivers. This section covers how to set up and manage database connections in FastAPI with SQLite and MongoDB. Database Integration in FastAPI using MongoDB Using SQLite with FastAPI Authentication in FastAPI FastAPI supports secure authentication and authorization using modern methods like OAuth2 and JWT. This section covers how to implement user login, permissions and protected routes with these approaches. Authentication and Authorization with FastAPI Advanced Topics in FastAPI FastAPI provides advanced features that make it ideal for production-ready applications. This section explores dependency injection, error handling and WebSockets, helping you build more powerful and scalable solutions. Dependency Injection in FastAPI Error Handling in FastAPI WebSockets in FastAPI Deployment &amp; Testing in FastAPI Deploying and testing are key steps to take your FastAPI app from development to production. This section shows how to deploy your app on Render and also how to test it effectively to ensure reliability. Deploy FastAPI using Render Testing FastAPI Application FastAPI Projects This section explores practical projects to help you apply FastAPI concepts in real-world scenarios, these projects will strengthen your hands-on experience. To-Do List App using FastAPI Login &amp; Registration System with JWT Chat App with WebSockets in FastAPI Applications of FastAPI FastAPI is widely used across industries due to its speed, simplicity, and strong validation features. Here are some common applications: RESTful APIs: Build reliable and scalable APIs for web and mobile applications. Data Validation Services: Use Pydantic models to clean and validate incoming data from users or external systems. File Upload &amp; Processing Systems: Ideal for applications like image hosting, resume upload portals and document management. Authentication &amp; Authorization: Implement secure login systems using JWT or OAuth2 for modern applications. Real-Time Applications: With WebSockets, build chat apps, live dashboards and collaborative tools. Machine Learning &amp; AI Integration: Serve ML models with FastAPI endpoints, enabling easy deployment of predictive services. Microservices: Perfect for building lightweight, independent services that communicate efficiently in distributed architectures. Comment H harshyeyi Follow Improve H harshyeyi Follow --> Like Article --> Improve Article Tags : Python FastAPI Explore Python Fundamentals Python Introduction 2 min read Input and Output in Python 4 min read Python Variables 5 min read Python Operators 4 min read Python Keywords 2 min read Python Data Types 7 min read Conditional Statements in Python 3 min read Loops in Python - For, While and Nested Loops 5 min read Python Functions 5 min read Recursion in Python 4 min read Python Lambda Functions 5 min read Python Data Structures Python String 5 min read Python Lists 4 min read Python Tuples 4 min read Python Dictionary 3 min read Python Sets 6 min read Python Arrays 7 min read List Comprehension in Python 4 min read Advanced Python Python OOP Concepts 11 min read Python Exception Handling 5 min read File Handling in Python 4 min read Python Database Tutorial 4 min read Python MongoDB Tutorial 2 min read Python MySQL 9 min read Python Packages 10 min read Python Modules 7 min read Python DSA Libraries 15 min read List of Python GUI Library and Packages 3 min read Data Science with Python NumPy Tutorial - Python Library 3 min read Pandas Tutorial 6 min read Matplotlib Tutorial 5 min read Python Seaborn Tutorial 15+ min read StatsModel Library- Tutorial 4 min read Learning Model Building in Scikit-learn 8 min read TensorFlow Tutorial 2 min read PyTorch Tutorial 6 min read Web Development with Python Flask Tutorial 8 min read Django Tutorial | Learn Django Framework 7 min read Django ORM - Inserting, Updating &amp; Deleting Data 4 min read Templating With Jinja2 in Flask 6 min read Django Templates 7 min read Python | Build a REST API using Flask 3 min read How to Create a basic API using Django Rest Framework ? 4 min read Python Practice Python Quiz 3 min read Python Coding Practice 1 min read Python Interview Questions and Answers 15+ min read Like Improve your Coding Skills with Practice Try It! --> &times; --> Corporate & Communications Address: A-143, 7th Floor, Sovereign Corporate Tower, Sector- 136, Noida, Uttar Pradesh (201305) Registered Address: K 061, Tower K, Gulshan Vivante Apartment, Sector 137, Noida, Gautam Buddh Nagar, Uttar Pradesh, 201305 Company About Us Legal Privacy Policy Contact Us Advertise with us GFG Corporate Solution Campus Training Program Explore POTD Job-A-Thon Blogs Nation Skill Up Tutorials Programming Languages DSA Web Technology AI, ML & Data Science DevOps CS Core Subjects Interview Preparation Software and Tools Courses IBM Certification DSA and Placements Web Development Programming Languages DevOps & Cloud GATE Trending Technologies Videos DSA Python Java C++ Web Development Data Science CS Subjects Preparation Corner Interview Corner Aptitude Puzzles GfG 160 System Design @GeeksforGeeks, Sanchhaya Education Private Limited , All rights reserved We use cookies to ensure you have the best browsing experience on our website. By using our site, you acknowledge that you have read and understood our Cookie Policy & Privacy Policy &nbsp;Cookies are not collected in the GeeksforGeeks mobile applications. Got It ! --> --> Improvement Suggest changes Suggest Changes Help us improve. Share your suggestions to enhance the article. Contribute your expertise and make a difference in the GeeksforGeeks portal. Create Improvement Enhance the article with your expertise. Contribute to the GeeksforGeeks community and help create better learning resources for all. Suggest Changes min 4 words, max Words Limit:1000 Thank You! Your suggestions are valuable to us. --> What kind of Experience do you want to share? Tell us your type of experiences which can help other fellow Geeks for their future events and preparations. --> Interview Experiences Admission Experiences Career Journeys Work Experiences Campus Experiences Competitive Exam Experiences Can't choose a topic to write? click here for suggested topics Write and publish your own Article --> linked-list 9172 -> AI-ML-DS, 1789 -> python 4667 -> math) -->

**Confidence**: 0.80

### Finding 3

Finding from Home - FastAPI Tutorial: Home - FastAPI Tutorial FastAPI Tutorial Home Tutorial Objectives Project Setup Test setup Async Handlers Routes Postgres setup Models POST route GET routes PUT route DELETE route Additional Validation GET POST PUT DELETE Conclusion References Original tutorial: Other references: &nbsp; FastAPI Tutorial Docs &raquo; Home FastAPI documentation : https://fastapi.tiangolo.com This tutorial app source code (GitLab repo) : Please, for more comprehension access the repo https://gitlab.com/rhkina/fastapi as you follow this tutorial! FastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.6+ based on standard Python type hints. Historically, async work in Python has been nontrivial (though its API has rapidly improved since Python 3.4) particularly with Flask. Essentially, Flask (on most WSGI servers) is blocking by default - work triggered by a request to a particular endpoint will hold the server entirely until that request is completed. Instead, Flask (or rather, the WSGI server running it, like gunicorn or uWSGI ) achieve scaling by running multiple worker instances of the app in parallel, such that requests can be farmed to other workers while one is busy. Within a single worker, asynchronous work can be wrapped in a blocking call (the route function itself is still blocking), threaded (in newer versions of Flask), or farmed to a queue manager like Celery - but there isn’t a single consistent story where routes can cleanly handle asynchronous requests without additional tooling. FastAPI is designed from the ground up to run asynchronously - thanks to its underlying starlette ASGI framework, route functions default to running within an asynchronous event loop. With a good ASGI server (FastAPI is designed to couple to uvicorn , running on top of uvloop ) this can get us performance on par with fast asynchronous webservers in Go or Node, without losing the benefits of Python’s broader machine learning ecosystem. In contrast to messing with threads or Celery queues to achieve asynchronous execution in Flask, running an endpoint asynchronously is dead simple in FastAPI - we simply declare the route function as asynchronous (with async def ) and we’re ready to go! We can even do this if the route function isn’t conventionally asynchronous - that is, we don’t have any awaitable calls (like if the endpoint is running inference against an ML model). In fact, unless the endpoint is specifically performing a blocking IO operation (to a database, for example), it’s better to declare the function with async def (as blocking functions are actually punted to an external threadpool and then awaited anyhow). The key features are: Fast : Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%.* Fewer bugs : Reduce about 40% of human (developer) induced errors.* Intuitive : Great editor support. Completion everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . * estimation based on tests performed by internal development team. Tutorial Note : original blog to this tutorial from Michael Herman at testdriven.io . Objectives I have the following objectives with this repo: Develop an asynchronous RESTful API with Python and FastAPI Practice Test-Driven Development Test a FastAPI app with Pytest Interact with a Postgres database asynchronously Containerize FastAPI and Postgres inside a Docker container Parameterize test functions and mock functionality in tests with Pytest Document a RESTful API with Swagger/OpenAPI Project Setup Create the following structure: fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ └── main.py └── requirements.txt Add FastAPI and Uvicorn to the requirements file: fastapi==0.54.1 uvicorn==0.11.3 Within main.py, create a new instance of FastAPI and set up a sanity check route: from fastapi import FastAPI app = FastAPI() @app.get(&quot;/ping&quot;) def pong(): return {&quot;ping&quot;: &quot;pong!&quot;} Add the following lines in the Dockerfile (at src directory): # pull official base image FROM python:3.8.1-alpine # set work directory WORKDIR /usr/src/app # set environment variables ENV PYTHONDONTWRITEBYTECODE 1 ENV PYTHONUNBUFFERED 1 # copy requirements file COPY ./requirements.txt /usr/src/app/requirements.txt # install dependencies RUN set -eux \ &amp;&amp; apk add --no-cache --virtual .build-deps build-base \ libressl-dev libffi-dev gcc musl-dev python3-dev \ &amp;&amp; pip install --upgrade pip setuptools wheel \ &amp;&amp; pip install -r /usr/src/app/requirements.txt \ &amp;&amp; rm -rf /root/.cache/pip # copy project COPY . /usr/src/app/ Here we started an Alpine-based Docker image for Python 3.8.1 and set a working directory defining two environment variables: PYTHONDONTWRITEBYTECODE : Prevents Python from writing pyc files to disc (equivalent to python -B option) PYTHONUNBUFFERED : Prevents Python from buffering stdout and stderr (equivalent to python -u option) Finally, we copied over the requirements.txt file, installed some system-level dependencies, updated Pip, installed the requirements, and copied over the FastAPI app itself. Next, add the following to the docker-compose.yml file in the project root: version: '2.0' services: web: build: ./src command: uvicorn app.main:app --reload --workers 1 --host 0.0.0.0 --port 8000 volumes: - ./src/:/usr/src/app/ ports: - 8002:8000 So, when the container spins up, Uvicorn will run with the following settings: --reload enables auto-reload so the server will restart after changes are made to the code base. --workers 1 provides a single worker process. --host 0.0.0.0 defines the address to host the server on. --port 8000 defines the port to host the server on. app.main:app tells Uvicorn where it can find the FastAPI ASGI application - e.g., within the 'app' module, you'll find the ASGI app, app = FastAPI() , in the main.py file. Build the image and spin up the container: $ docker-compose up -d --build Navigate to http://localhost:8002/ping . You should see: {"ping":"pong!"} You'll also be able to view the interactive API documentation, powered by Swagger UI, at http://localhost:8002/docs : Test setup Create a tests folder in src and then add an __init__.py file to tests along with a test_main.py file: from starlette.testclient import TestClient from app.main import app client = TestClient(app) def test_ping(): response = client.get(&quot;/ping&quot;) assert response.status_code == 200 assert response.json() == {&quot;ping&quot;: &quot;pong!&quot;} Here, we imported Starlette's TestClient , which uses the Requests library to make requests against the FastAPI app. Add Pytest and Requests to requirements.txt : fastapi==0.54.1 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Update the image and then run the tests: $ docker-compose up -d --build $ docker-compose exec web pytest . You should see something like this: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_main.py . [100%] =========================================== 1 passed in 0.48s =========================================== Add a test_app Pytest fixture to a new file called src/tests/conftest.py : import pytest from starlette.testclient import TestClient from app.main import app @pytest.fixture(scope=&quot;module&quot;) def test_app(): client = TestClient(app) yield client # testing happens here Update the test_main.py file as well so that it uses the fixture: def test_ping(test_app): response = client.get(&quot;/ping&quot;) assert response.status_code == 200 assert response.json() == {&quot;ping&quot;: &quot;pong!&quot;} Your project structure should now look like this: fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ └── main.py ├── requirements.txt └── tests ├── __init__.py ├── conftest.py └── test_main.py Async Handlers Let's convert the synchronous handler over to an asynchronous one. Rather than having to go through the trouble of spinning up a task queue (like Celery or RQ) or utilizing threads, FastAPI makes it easy to deliver routes asynchronously. As long as you don't have any blocking I/O calls in the handler, you can simply declare the handler as asynchronous by just adding the async keyword like so (modify main.py ): @app.get(&quot;/ping&quot;) async def pong(): # some async operation could happen here # example: `notes = await get_all_notes()` return {&quot;ping&quot;: &quot;pong!&quot;} That's it! Update the handler in your code, and then make sure the tests still pass: $ docker-compose up -d --build $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_main.py . [100%] =========================================== 1 passed in 0.03s =========================================== Routes Next, let's set up the basic CRUD routes, following RESTful best practices: Endpoint HTTP Method CRUD Method Result /notes/ GET READ get all notes /notes/:id GET READ get a single note /notes/ POST CREATE add a note /notes/:id PUT UPDATE update a note /notes/:id DELETE DELETE delete a note For each route, we will: Write a test Run the test to ensure it fails (red) Write just enough code to get the test to pass (green) Refactor Before diving in, let's add some structure to better organize the CRUD routes with FastAPI's APIRouter . You can break up and modularize larger projects as well as apply versioning to your API with the APIRouter . If you're familiar with Flask, it is equivalent to a Blueprint . Add a new folder called api to the app folder, and add an __init__.py file to the newly created folder. Now we can move the /ping route to a new file called src/app/api/ping.py : from fastapi import APIRouter router = APIRouter() @router.get(&quot;/ping&quot;) async def pong(): # some async operation could happen here # example: `notes = await get_all_notes()` return {&quot;ping&quot;: &quot;pong!&quot;} Then, update main.py like so to remove the old route and wire the router up to our main app: from fastapi import FastAPI from app.api import ping app = FastAPI() app.include_router(ping.router) Rename test_main.py to test_ping.py . Make sure http://localhost:8002/ping and http://localhost:8002/docs still work. Also, be sure the tests still pass before moving on. $ docker-compose up -d --build $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 1 item tests/test_ping.py . [100%] =========================================== 1 passed in 0.04s =========================================== Postgres setup To configure Postgres, we'll need to add a new service to the docker-compose.yml file, add the appropriate environment variables, and install asyncpg . First, add a new service called db to docker-compose.yml : version: '2.0' services: web: build: ./src command: uvicorn app.main:app --reload --workers 1 --host 0.0.0.0 --port 8000 volumes: - ./src/:/usr/src/app/ ports: - 8002:8000 environment: - DATABASE_URL=postgresql://hello_fastapi:hello_fastapi@db/hello_fastapi_dev db: image: postgres:12.1-alpine volumes: - postgres_data:/var/lib/postgresql/data/ environment: - POSTGRES_USER=hello_fastapi - POSTGRES_PASSWORD=hello_fastapi - POSTGRES_DB=hello_fastapi_dev volumes: postgres_data: To persist the data beyond the life of the container we configured a volume. This config will bind postgres_data to the /var/lib/postgresql/data/ directory in the container. We also added an environment key to define a name for the default database and set a username and password. Review the "Environment Variables" section of the Postgres Docker Hub page for more info. Update the Dockerfile to install the appropriate packages required for asyncpg : # pull official base image FROM python:3.8.1-alpine # set work directory WORKDIR /usr/src/app # set environment variables ENV PYTHONDONTWRITEBYTECODE 1 ENV PYTHONUNBUFFERED 1 # copy requirements file COPY ./requirements.txt /usr/src/app/requirements.txt # install dependencies RUN set -eux \ &amp;&amp; apk add --no-cache --virtual .build-deps build-base \ libressl-dev libffi-dev gcc musl-dev python3-dev \ postgresql-dev \ &amp;&amp; pip install --upgrade pip setuptools wheel \ &amp;&amp; pip install -r /usr/src/app/requirements.txt \ &amp;&amp; rm -rf /root/.cache/pip # copy project COPY . /usr/src/app/ Add asyncpg to src/requirements.txt : asyncpg==0.20.0 fastapi==0.54.1 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Next, add a db.py file to src/app : import os from databases import Database from sqlalchemy import create_engine, MetaData DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;) # SQLAlchemy engine = create_engine(DATABASE_URL) metadata = MetaData() # databases query builder database = Database(DATABASE_URL) Here, using the database URI and credentials that we just configured in the Docker Compose file, we created a SQLAlchemy engine (used for communicating with the database) along with a Metadata instance (used for creating the database schema). We also created a new Database instance from databases . databases is an async SQL query builder that works on top of the SQLAlchemy Core expression language. It supports the following methods: database.fetch_all(query) database.fetch_one(query) database.iterate(query) database.execute(query) database.execute_many(query) Review the Async SQL (Relational) Databases guide and the Starlette Database docs for more details on working with databases asynchronously. Update the requirements.txt : asyncpg==0.20.0 databases[postgresql]==0.2.6 fastapi==0.54.1 SQLAlchemy==1.3.16 uvicorn==0.11.3 # dev pytest==5.4.1 requests==2.23.0 Models SQLAlchemy Model Add a notes model to src/app/db.py : import os from sqlalchemy import (Column, DateTime, Integer, MetaData, String, Table, create_engine) from sqlalchemy.sql import func from databases import Database DATABASE_URL = os.getenv(&quot;DATABASE_URL&quot;) # SQLAlchemy engine = create_engine(DATABASE_URL) metadata = MetaData() notes = Table( &quot;notes&quot;, metadata, Column(&quot;id&quot;, Integer, primary_key=True), Column(&quot;title&quot;, String(50)), Column(&quot;description&quot;, String(50)), Column(&quot;created_date&quot;, DateTime, default=func.now(), nullable=False), ) # databases query builder database = Database(DATABASE_URL) Wire up the database and the model in main.py and add startup and shutdown event handlers for connecting to and disconnecting from the database: from fastapi import FastAPI from app.api import notes, ping from app.db import engine, metadata, database metadata.create_all(engine) app = FastAPI() @app.on_event(&quot;startup&quot;) async def startup(): await database.connect() @app.on_event(&quot;shutdown&quot;) async def shutdown(): await database.disconnect() app.include_router(ping.router) Build the new image and spin up the two containers: $ docker-compose up -d --build Ensure the notes table was created: $ docker-compose exec db psql --username=hello_fastapi --dbname=hello_fastapi_dev psql (12.1) Type &quot;help&quot; for help. hello_fastapi_dev=# \l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges -------------------+---------------+----------+------------+------------+--------------------------------- hello_fastapi_dev | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | postgres | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | template0 | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | =c/hello_fastapi + | | | | | hello_fastapi=CTc/hello_fastapi template1 | hello_fastapi | UTF8 | en_US.utf8 | en_US.utf8 | =c/hello_fastapi + | | | | | hello_fastapi=CTc/hello_fastapi (4 rows) hello_fastapi_dev=# \c hello_fastapi_dev You are now connected to database &quot;hello_fastapi_dev&quot; as user &quot;hello_fastapi&quot;. hello_fastapi_dev=# \dt List of relations Schema | Name | Type | Owner --------+-------+-------+--------------- public | notes | table | hello_fastapi (1 row) hello_fastapi_dev=# \q Pydantic model First time using pydantic? View pydantic Overview for more details. Create a NoteSchema pydantic model with two required fields, title and description , in a new file called models.py in src/app/api : from pydantic import BaseModel class NoteSchema(BaseModel): title: str description: str NoteSchema will be used for validating the payloads for creating and updating notes. POST route We will break the normal TDD flow for this route in order to establish the coding pattern that we'll use for the remaining routes. Code Create a new file called notes.py in the src/app/api folder: from app.api import crud from app.api.models import NoteDB, NoteSchema from fastapi import APIRouter, HTTPException router = APIRouter() @router.post(&quot;/&quot;, response_model=NoteDB, status_code=201) async def create_note(payload: NoteSchema): note_id = await crud.post(payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object Here, we defined a handler that expects a payload, payload: NoteSchema , with a title and a description . Essentially, when the route is hit with a POST request, FastAPI will read the body of the request and validate the data: - If valid, the data will be available in the payload parameter. FastAPI also generates JSON Schema definitions that are then used to automatically generate the OpenAPI schema and the API documentation. - If invalid, an error is immediately returned. Review the Request Body for more info. Note that we used the async declaration here since the database communication will be asynchronous. In other words, there are no blocking I/O operations in the handler. Next, create a new file called crud.py in the src/app/api folder: from app.api.models import NoteSchema from app.db import notes, database async def post(payload: NoteSchema): query = notes.insert().values(title=payload.title, description=payload.description) return await database.execute(query=query) We added a utility function called post for creating new notes that takes a payload object and then: Creates a SQLAlchemy insert object expression query. Executes the query and returns the generated ID. Next, we need to define a new pydantic model for use as the response_model : @router.post("/", response_model=NoteDB, status_code=201) Update models.py like so: from pydantic import BaseModel class NoteSchema(BaseModel): title: str description: str class NoteDB(NoteSchema): id: int The NoteDB model inherits from the NoteSchema model, adding an id field. Wire up the new router in main.py : from app.api import notes, ping from app.db import database, engine, metadata from fastapi import FastAPI metadata.create_all(engine) app = FastAPI() @app.on_event(&quot;startup&quot;) async def startup(): await database.connect() @app.on_event(&quot;shutdown&quot;) async def shutdown(): await database.disconnect() app.include_router(ping.router) app.include_router(notes.router, prefix=&quot;/notes&quot;, tags=[&quot;notes&quot;]) Take note of the prefix URL along with the notes tag , which will be applied to the OpenAPI schema (for grouping operations ). Test it out with curl or HTTPie : $ http --json POST http://localhost:8002/notes/ title=foo description=bar You should see something like: HTTP/1.1 201 Created content-length: 42 content-type: application/json date: Sun, 12 Apr 2020 04:39:56 GMT server: uvicorn { &quot;description&quot;: &quot;bar&quot;, &quot;id&quot;: 1, &quot;title&quot;: &quot;foo&quot; } You can also interact with the endpoint at http://localhost:8002/docs/ . Test Add the following test to a new test file called src/tests/test_notes.py : import json import pytest from app.api import crud def test_create_note(test_app, monkeypatch): test_request_payload = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} test_response_payload = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_post(payload): return 1 monkeypatch.setattr(crud, &quot;post&quot;, mock_post) response = test_app.post(&quot;/notes/&quot;, data=json.dumps(test_request_payload),) assert response.status_code == 201 assert response.json() == test_response_payload def test_create_note_invalid_json(test_app): response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;something&quot;})) assert response.status_code == 422 This test uses the Pytest monkeypatch fixture to mock out the crud.post function. We then asserted that the endpoint responds with the expected status codes and response body. $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 3 items tests/test_notes.py .. [ 66%] tests/test_ping.py . [100%] =========================================== 3 passed in 0.05s =========================================== Now we can configure the remaining CRUD routes using Test-Driven Development. fastapi ├── docker-compose.yml └── src ├── Dockerfile ├── app │ ├── __init__.py │ ├── api │ │ ├── __init__.py │ │ ├── crud.py │ │ ├── models.py │ │ ├── notes.py │ │ └── ping.py │ ├── db.py │ └── main.py ├── requirements.txt └── tests ├── __init__.py ├── conftest.py ├── test_notes.py └── test_ping.py GET routes GET one note Test Add the following tests (inside test_notes.py ): def test_read_note(test_app, monkeypatch): test_data = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/1&quot;) assert response.status_code == 200 assert response.json() == test_data def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; Run tests: docker-compose exec web pytest . They should fail: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 3 items tests/test_notes.py .. [ 66%] tests/test_ping.py . [100%] =========================================== 3 passed in 0.05s =========================================== (base) rhkina@rhkina-ThinkPad-T440:~/Workspace/fastapi$ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 5 items tests/test_notes.py ..FF [ 80%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ____________________________________________ test_read_note _____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f8c5297e8b0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8c5297e6d0&gt; def test_read_note(test_app, monkeypatch): test_data = {&quot;id&quot;: 1, &quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;} async def mock_get(id): return test_data &gt; monkeypatch.setattr(crud, &quot;get&quot;, mock_get) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get' tests/test_notes.py:29: AttributeError ______________________________________ test_read_note_incorrect_id ______________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f8c5297e8b0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f8c52615e20&gt; def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None &gt; monkeypatch.setattr(crud, &quot;get&quot;, mock_get) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get' tests/test_notes.py:39: AttributeError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/app... FAILED tests/test_notes.py::test_read_note_incorrect_id - AttributeError: &lt;module 'app.api.crud' from ... ====================================== 2 failed, 3 passed in 0.13s ====================================== Code Add the handler (inside notes.py ): @router.get(&quot;/{id}/&quot;, response_model=NoteDB) async def read_note(id: int): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) return note Here, instead of taking a payload, the handler requires an id , an integer, which will come from the path -- i.e., /notes/5/ . Add the get utility function to crud.py : async def get(id: int): query = notes.select().where(id == notes.c.id) return await database.fetch_one(query=query) Before moving on, ensure the tests pass and manually test the new endpoint in the browser, with curl or HTTPie, and/or via the API documentation. GET all notes Test Next, add a test for reading all notes: def test_read_all_notes(test_app, monkeypatch): test_data = [ {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1}, {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 2}, ] async def mock_get_all(): return test_data monkeypatch.setattr(crud, &quot;get_all&quot;, mock_get_all) response = test_app.get(&quot;/notes/&quot;) assert response.status_code == 200 assert response.json() == test_data Again, make sure the test fails. docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 6 items tests/test_notes.py ....F [ 83%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ __________________________________________ test_read_all_notes __________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7fefa6ffa8e0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7fefa6ffadf0&gt; def test_read_all_notes(test_app, monkeypatch): test_data = [ {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1}, {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 2}, ] async def mock_get_all(): return test_data &gt; monkeypatch.setattr(crud, &quot;get_all&quot;, mock_get_all) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'get_all' tests/test_notes.py:54: AttributeError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_all_notes - AttributeError: &lt;module 'app.api.crud' from '/usr/sr... ====================================== 1 failed, 5 passed in 0.14s ====================================== Code Handler Add the following code to notes.py : @router.get(&quot;/&quot;, response_model=List[NoteDB]) async def read_all_notes(): return await crud.get_all() And import List from Python's typing module (include at the top of the notes.py ): from typing import List The response_model is a List with a NoteDB subtype. Util Add the CRUD util at crud.py : async def get_all(): query = notes.select() return await database.fetch_all(query=query) Make sure the automated tests pass now. Manually test this endpoint as well. docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 6 items tests/test_notes.py ..... [ 83%] tests/test_ping.py . [100%] =========================================== 6 passed in 0.08s =========================================== PUT route Test Add the code to the test_notes.py : def test_update_note(test_app, monkeypatch): test_update_data = {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 1} async def mock_get(id): return True monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_put(id, payload): return 1 monkeypatch.setattr(crud, &quot;put&quot;, mock_put) response = test_app.put(&quot;/notes/1/&quot;, data=json.dumps(test_update_data)) assert response.status_code == 200 assert response.json() == test_update_data @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) assert response.status_code == status_code This test uses the Pytest parametrize decorator to parametrize the arguments for the test_update_note_invalid function. Run tests: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 10 items tests/test_notes.py .....FFFF [ 90%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ___________________________________________ test_update_note ____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04899846a0&gt; def test_update_note(test_app, monkeypatch): test_update_data = {&quot;title&quot;: &quot;someone&quot;, &quot;description&quot;: &quot;someone else&quot;, &quot;id&quot;: 1} async def mock_get(id): return True monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_put(id, payload): return 1 &gt; monkeypatch.setattr(crud, &quot;put&quot;, mock_put) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'put' tests/test_notes.py:71: AttributeError _______________________________ test_update_note_invalid[1-payload0-422] ________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f0489976100&gt;, id = 1, payload = {} status_code = 422 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 422 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError _______________________________ test_update_note_invalid[1-payload1-422] ________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04898577c0&gt;, id = 1 payload = {'description': 'bar'}, status_code = 422 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 422 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError ______________________________ test_update_note_invalid[999-payload2-404] _______________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f0489984a90&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f04898666d0&gt;, id = 999 payload = {'description': 'bar', 'title': 'foo'}, status_code = 404 @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) &gt; assert response.status_code == status_code E assert 405 == 404 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:93: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_update_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/a... FAILED tests/test_notes.py::test_update_note_invalid[1-payload0-422] - assert 405 == 422 FAILED tests/test_notes.py::test_update_note_invalid[1-payload1-422] - assert 405 == 422 FAILED tests/test_notes.py::test_update_note_invalid[999-payload2-404] - assert 405 == 404 ====================================== 4 failed, 6 passed in 0.21s ====================================== Code Handler ( notes.py ) @router.put(&quot;/{id}/&quot;, response_model=NoteDB) async def update_note(id: int, payload: NoteSchema): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) note_id = await crud.put(id, payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object Util ( crud.py ) async def put(id: int, payload: NoteSchema): query = ( notes .update() .where(id == notes.c.id) .values(title=payload.title, description=payload.description) .returning(notes.c.id) ) return await database.execute(query=query) Run tests: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 10 items tests/test_notes.py ......... [ 90%] tests/test_ping.py . [100%] ========================================== 10 passed in 0.12s =========================================== Manually test this endpoint as well. DELETE route Test In test_notes.py add: def test_remove_note(test_app, monkeypatch): test_data = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_delete(id): return id monkeypatch.setattr(crud, &quot;delete&quot;, mock_delete) response = test_app.delete(&quot;/notes/1/&quot;) assert response.status_code == 200 assert response.json() == test_data def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; Run tests and make sure you get errors: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py .........FF [ 91%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ___________________________________________ test_remove_note ____________________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f30ec5cb730&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f30ec5900a0&gt; def test_remove_note(test_app, monkeypatch): test_data = {&quot;title&quot;: &quot;something&quot;, &quot;description&quot;: &quot;something else&quot;, &quot;id&quot;: 1} async def mock_get(id): return test_data monkeypatch.setattr(crud, &quot;get&quot;, mock_get) async def mock_delete(id): return id &gt; monkeypatch.setattr(crud, &quot;delete&quot;, mock_delete) E AttributeError: &lt;module 'app.api.crud' from '/usr/src/app/app/api/crud.py'&gt; has no attribute 'delete' tests/test_notes.py:106: AttributeError _____________________________________ test_remove_note_incorrect_id _____________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f30ec5cb730&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f30ec5da970&gt; def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) &gt; assert response.status_code == 404 E assert 405 == 404 E + where 405 = &lt;Response [405]&gt;.status_code tests/test_notes.py:120: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_remove_note - AttributeError: &lt;module 'app.api.crud' from '/usr/src/a... FAILED tests/test_notes.py::test_remove_note_incorrect_id - assert 405 == 404 ===================================== 2 failed, 10 passed in 0.19s ====================================== Code Handler ( notes.py ) @router.delete(&quot;/{id}/&quot;, response_model=NoteDB) async def delete_note(id: int): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) await crud.delete(id) return note Util ( crud.py ) async def delete(id: int): query = notes.delete().where(id == notes.c.id) return await database.execute(query=query) Make sure all tests pass: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ........... [ 91%] tests/test_ping.py . [100%] ========================================== 12 passed in 0.13s =========================================== Additional Validation Let's add some additional validation to routes, checking: The id is greater than 0 for reading a single note, updating a note, and deleting a note. The title and description fields from the request payloads must have lengths &gt;= 3 and &lt;= 50 for adding and updating a note. GET Update the test_read_note_incorrect_id test in test_notes.py : def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.get(&quot;/notes/0&quot;) assert response.status_code == 422 The test should fail: docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ...F....... [ 91%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ ______________________________________ test_read_note_incorrect_id ______________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7f5d02bfac10&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7f5d02bfa280&gt; def test_read_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.get(&quot;/notes/999&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.get(&quot;/notes/0&quot;) &gt; assert response.status_code == 422 E assert 404 == 422 E + where 404 = &lt;Response [404]&gt;.status_code tests/test_notes.py:46: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_read_note_incorrect_id - assert 404 == 422 ===================================== 1 failed, 11 passed in 0.19s ====================================== Update the handler (in notes.py ): @router.get(&quot;/{id}/&quot;, response_model=NoteDB) async def read_note(id: int = Path(..., gt=0),): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) return note Make sure to import Path (at the top of notes.py ); from fastapi import APIRouter, HTTPException, Path So, we added the following metadata to the parameter with Path : 1. ... - the value is required ( Ellipsis ) 2. gt - the value must be greater than 0 The tests should pass: $ docker-compose exec web pytest . ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 12 items tests/test_notes.py ........... [ 91%] tests/test_ping.py . [100%] ========================================== 12 passed in 0.13s =========================================== Try out the API documentation as well: POST Update the test_create_note_invalid_json test ( test_notes.py ): def test_create_note_invalid_json(test_app): response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;something&quot;})) assert response.status_code == 422 response = test_app.post(&quot;/notes/&quot;, data=json.dumps({&quot;title&quot;: &quot;1&quot;, &quot;description&quot;: &quot;2&quot;})) assert response.status_code == 422 Run the test and you should see the error (now on, I will not show the command and the result). To get the test to pass, update the NoteSchema (in models.py ) like so: class NoteSchema(BaseModel): title: str = Field(..., min_length=3, max_length=50) description: str = Field(..., min_length=3, max_length=50) As we added additional validation to the pydantic model with Field , add the import (in the same models.py file): from pydantic import BaseModel, Field PUT Add three more scenarios to test_update_note_invalid ( test_notes.py ): @pytest.mark.parametrize( &quot;id, payload, status_code&quot;, [ [1, {}, 422], [1, {&quot;description&quot;: &quot;bar&quot;}, 422], [999, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 404], [1, {&quot;title&quot;: &quot;1&quot;, &quot;description&quot;: &quot;bar&quot;}, 422], [1, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;1&quot;}, 422], [0, {&quot;title&quot;: &quot;foo&quot;, &quot;description&quot;: &quot;bar&quot;}, 422], ], ) def test_update_note_invalid(test_app, monkeypatch, id, payload, status_code): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.put(f&quot;/notes/{id}/&quot;, data=json.dumps(payload),) assert response.status_code == status_code Handler notes.py : @router.put(&quot;/{id}/&quot;, response_model=NoteDB) async def update_note(payload: NoteSchema, id: int = Path(..., gt=0),): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) note_id = await crud.put(id, payload) response_object = { &quot;id&quot;: note_id, &quot;title&quot;: payload.title, &quot;description&quot;: payload.description, } return response_object DELETE Test ( test_notes.py ): def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.delete(&quot;/notes/0/&quot;) assert response.status_code == 422 Test Error : ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 15 items tests/test_notes.py .............F [ 93%] tests/test_ping.py . [100%] =============================================== FAILURES ================================================ _____________________________________ test_remove_note_incorrect_id _____________________________________ test_app = &lt;starlette.testclient.TestClient object at 0x7ff9374014f0&gt; monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7ff9373b4460&gt; def test_remove_note_incorrect_id(test_app, monkeypatch): async def mock_get(id): return None monkeypatch.setattr(crud, &quot;get&quot;, mock_get) response = test_app.delete(&quot;/notes/999/&quot;) assert response.status_code == 404 assert response.json()[&quot;detail&quot;] == &quot;Note not found&quot; response = test_app.delete(&quot;/notes/0/&quot;) &gt; assert response.status_code == 422 E assert 404 == 422 E + where 404 = &lt;Response [404]&gt;.status_code tests/test_notes.py:133: AssertionError ======================================== short test summary info ======================================== FAILED tests/test_notes.py::test_remove_note_incorrect_id - assert 404 == 422 ===================================== 1 failed, 14 passed in 0.23s ====================================== Handler ( notes.py ): @router.delete(&quot;/{id}/&quot;, response_model=NoteDB) async def delete_note(id: int = Path(..., gt=0)): note = await crud.get(id) if not note: raise HTTPException(status_code=404, detail=&quot;Note not found&quot;) await crud.delete(id) return note The tests should pass: ========================================== test session starts ========================================== platform linux -- Python 3.8.1, pytest-5.4.1, py-1.8.1, pluggy-0.13.1 rootdir: /usr/src/app collected 15 items tests/test_notes.py .............. [ 93%] tests/test_ping.py . [100%] ========================================== 15 passed in 0.16s =========================================== Conclusion FastAPI is an awesome asynchronous Python micro framework! With Flask-like simplicity, it is easy and fun to update your Flask RESTful API to asynchronous mode. Hope you have enjoyed! References Original tutorial: Herman, Michael - Developing and Testing an Asynchronous API with FastAPI and Pytest Other references: FastAPI Official Documentation - https://fastapi.tiangolo.com/ Uvicorn Official Documentation - https://fastapi.tiangolo.com/ Starlette Official Documentation - https://www.starlette.io/ Pydantic Official Documentation - https://pydantic-docs.helpmanual.io/ Built with MkDocs using a theme provided by Read the Docs .

**Confidence**: 0.80

## Sources

1. [FastAPI](https://fastapi.tiangolo.com/) - Relevance: 0.80
   > DuckDuckGo result for: Python FastAPI

2. [FastAPI Tutorial - GeeksforGeeks](https://www.geeksforgeeks.org/python/fastapi-tutorial/) - Relevance: 0.80
   > DuckDuckGo result for: Python FastAPI

3. [Home - FastAPI Tutorial](https://fastapi-tutorial.readthedocs.io/en/latest/) - Relevance: 0.80
   > DuckDuckGo result for: Python FastAPI

